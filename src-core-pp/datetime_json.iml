(** JSON printers/parsers for datetime types. *)
(***

    Imandra Inc.
    Copyright (c) 2014 - 2019

    datetime_json.iml 
*)
[@@@import "../src-core/datetime.iml"]
[@@@import "base_types_json.iml"]
[@@@program]
open Yojson;;
open Datetime;;
open Base_types_json;;
module JU = Yojson.Basic.Util;;
module D = Decoders_yojson.Basic.Decode;; 
open D.Infix;;



let filter_nulls =
  List.filter (function ( _, `Null ) -> false | _ -> true )
;;

let utctimestamp_milli_to_json ( ts : fix_utctimestamp_milli )  =
  let list_assoc = [
    ( "utc_timestamp_year"     , int_to_json ts.utc_timestamp_year                     );
    ( "utc_timestamp_month"    , int_to_json ts.utc_timestamp_month                    );
    ( "utc_timestamp_day"      , int_to_json ts.utc_timestamp_day                      );
    ( "utc_timestamp_hour"     , int_to_json ts.utc_timestamp_hour                     );
    ( "utc_timestamp_minute"   , int_to_json ts.utc_timestamp_minute                   );
    ( "utc_timestamp_second"   , int_to_json ts.utc_timestamp_second                   );
    ( "utc_timestamp_millisec" , int_opt_to_json ts.utc_timestamp_millisec      );
  ] |> filter_nulls in
  `Assoc list_assoc
;;

let utctimestamp_milli_decoder : fix_utctimestamp_milli Decoders_yojson.Basic.Decode.decoder = 
  (D.field "utc_timestamp_year" int_decoder) >>= fun utc_timestamp_year -> 
  (D.field "utc_timestamp_month" int_decoder) >>= fun utc_timestamp_month ->
  (D.field "utc_timestamp_day" int_decoder) >>= fun utc_timestamp_day -> 
  (D.field "utc_timestamp_hour" int_decoder) >>= fun utc_timestamp_hour ->
  (D.field "utc_timestamp_minute" int_decoder) >>= fun utc_timestamp_minute ->
  (D.field "utc_timestamp_second" int_decoder) >>= fun utc_timestamp_second ->
  D.maybe (D.field "utc_timestamp_millisec" int_decoder) >>= fun utc_timestamp_millisec ->
  D.succeed {
    utc_timestamp_year   
  ; utc_timestamp_month  
  ; utc_timestamp_day    
  ; utc_timestamp_hour   
  ; utc_timestamp_minute 
  ; utc_timestamp_second 
  ; utc_timestamp_millisec
  };;

let utctimestamp_micro_to_json ( ts : fix_utctimestamp_micro )  =
  let list_assoc = [
    ( "utc_timestamp_year"     , int_to_json ts.utc_timestamp_year                     );
    ( "utc_timestamp_month"    , int_to_json ts.utc_timestamp_month                    );
    ( "utc_timestamp_day"      , int_to_json ts.utc_timestamp_day                      );
    ( "utc_timestamp_hour"     , int_to_json ts.utc_timestamp_hour                     );
    ( "utc_timestamp_minute"   , int_to_json ts.utc_timestamp_minute                   );
    ( "utc_timestamp_second"   , int_to_json ts.utc_timestamp_second                   );
    ( "utc_timestamp_microsec" , int_opt_to_json ts.utc_timestamp_microsec      );
  ] |> filter_nulls in
  `Assoc list_assoc
;;

let utctimestamp_micro_decoder : fix_utctimestamp_micro Decoders_yojson.Basic.Decode.decoder = 
  (D.field "utc_timestamp_year" int_decoder) >>= fun utc_timestamp_year -> 
  (D.field "utc_timestamp_month" int_decoder) >>= fun utc_timestamp_month ->
  (D.field "utc_timestamp_day" int_decoder) >>= fun utc_timestamp_day -> 
  (D.field "utc_timestamp_hour" int_decoder) >>= fun utc_timestamp_hour ->
  (D.field "utc_timestamp_minute" int_decoder) >>= fun utc_timestamp_minute ->
  (D.field "utc_timestamp_second" int_decoder) >>= fun utc_timestamp_second ->
  D.maybe (D.field "utc_timestamp_microsec" int_decoder) >>= fun utc_timestamp_microsec ->
  D.succeed {
    utc_timestamp_year   
  ; utc_timestamp_month  
  ; utc_timestamp_day    
  ; utc_timestamp_hour   
  ; utc_timestamp_minute 
  ; utc_timestamp_second 
  ; utc_timestamp_microsec
  };;

let utctimestamp_milli_opt_to_json = function
  | None    -> `Null
  | Some x  -> utctimestamp_milli_to_json x
;;

let utctimestamp_micro_opt_to_json = function
  | None    -> `Null
  | Some x  -> utctimestamp_micro_to_json x
;;

let duration_to_json ( d : fix_duration ) = 
  let list_assoc = [
    ( "dur_years"   , int_to_json d.dur_years   );
    ( "dur_months"  , int_to_json d.dur_months  );
    ( "dur_days"    , int_to_json d.dur_days    );
    ( "dur_hours"   , int_to_json d.dur_hours   );
    ( "dur_minutes" , int_to_json d.dur_minutes );
    ( "dur_seconds" , int_to_json d.dur_seconds );
  ] |> filter_nulls in 
  `Assoc list_assoc
;;

let duration_decoder : fix_duration Decoders_yojson.Basic.Decode.decoder = 
  (D.field "dur_years" int_decoder) >>= fun dur_years -> 
  (D.field "dur_months" int_decoder) >>= fun dur_months ->
  (D.field "dur_days" int_decoder) >>= fun dur_days -> 
  (D.field "dur_hours" int_decoder) >>= fun dur_hours ->
  (D.field "dur_minutes" int_decoder) >>= fun dur_minutes ->
  (D.field "dur_seconds" int_decoder) >>= fun dur_seconds ->                        
  D.succeed {
    dur_years   
  ; dur_months  
  ; dur_days    
  ; dur_hours   
  ; dur_minutes 
  ; dur_seconds                            
  };;

let duration_opt_to_json = function
  | None   -> `Null
  | Some x -> duration_to_json x
;;

let localmktdate_to_json ( d : fix_localmktdate ) =
  let list_assoc = [
    ( "localmktdate_year"  , int_to_json d.localmktdate_year  );
    ( "localmktdate_month" , int_to_json d.localmktdate_month );
    ( "localmktdate_day"   , int_to_json d.localmktdate_day   );
  ] |> filter_nulls in
  `Assoc list_assoc
;;

let localmktdate_decoder : fix_localmktdate Decoders_yojson.Basic.Decode.decoder = 
  (D.field "localmktdate_year" int_decoder) >>= fun localmktdate_year -> 
  (D.field "localmktdate_month" int_decoder) >>= fun localmktdate_month ->
  (D.field "localmktdate_day" int_decoder) >>= fun localmktdate_day ->                    
  D.succeed {
    localmktdate_year   
  ; localmktdate_month  
  ; localmktdate_day                           
  };;

let localmktdate_opt_to_json = function
  | None    -> `Null
  | Some x  -> localmktdate_to_json x
;;

let utcdateonly_to_json ( d : fix_utcdateonly ) =  
  let list_assoc = [
    ( "utc_dateonly_year"  , int_to_json d.utc_dateonly_year  );
    ( "utc_dateonly_month" , int_to_json d.utc_dateonly_month );
    ( "utc_dateonly_day"   , int_to_json d.utc_dateonly_day   )
  ] |> filter_nulls in
  `Assoc list_assoc
;;

let utcdateonly_decoder : fix_utcdateonly Decoders_yojson.Basic.Decode.decoder = 
  (D.field "utc_dateonly_year" int_decoder) >>= fun utc_dateonly_year -> 
  (D.field "utc_dateonly_month" int_decoder) >>= fun utc_dateonly_month ->
  (D.field "utc_dateonly_day" int_decoder) >>= fun utc_dateonly_day ->                    
  D.succeed {
    utc_dateonly_year   
  ; utc_dateonly_month  
  ; utc_dateonly_day                           
  };;

let utcdateonly_opt_to_json = function  
  | None    -> `Null
  | Some x  -> utcdateonly_to_json x
;;

(** UTC Timeonly *)
let utctimeonly_milli_to_json ( d : fix_utctimeonly_milli ) = 
  let list_assoc = [
    ( "utc_timeonly_hour"     ,  int_to_json d.utc_timeonly_hour          );    
    ( "utc_timeonly_minute"   ,  int_to_json d.utc_timeonly_minute        );
    ( "utc_timeonly_second"   ,  int_to_json d.utc_timeonly_second        );
    ( "utc_timeonly_millisec" ,  int_opt_to_json d.utc_timeonly_millisec  ) 
  ] |> filter_nulls in
  `Assoc list_assoc
;;

let utctimeonly_milli_decoder : fix_utctimeonly_milli Decoders_yojson.Basic.Decode.decoder = 
  (D.field "utc_timeonly_hour" int_decoder) >>= fun utc_timeonly_hour -> 
  (D.field "utc_timeonly_minute" int_decoder) >>= fun utc_timeonly_minute ->
  (D.field "utc_timeonly_second" int_decoder) >>= fun utc_timeonly_second ->                    
  D.maybe (D.field "utc_timeonly_millisec" int_decoder) >>= fun utc_timeonly_millisec ->     
  D.succeed {
    utc_timeonly_hour   
  ; utc_timeonly_minute  
  ; utc_timeonly_second
  ; utc_timeonly_millisec                           
  };;

let utctimeonly_milli_opt_to_json  = function
  | None    -> `Null
  | Some x  -> utctimeonly_milli_to_json x
;;

let utctimeonly_micro_to_json ( d : fix_utctimeonly_micro ) = 
  let list_assoc = [
    ( "utc_timeonly_hour"     ,  int_to_json d.utc_timeonly_hour          );    
    ( "utc_timeonly_minute"   ,  int_to_json d.utc_timeonly_minute        );
    ( "utc_timeonly_second"   ,  int_to_json d.utc_timeonly_second        );
    ( "utc_timeonly_microsec" ,  int_opt_to_json d.utc_timeonly_microsec  ) 
  ] |> filter_nulls in
  `Assoc list_assoc
;;

let utctimeonly_micro_decoder : fix_utctimeonly_micro Decoders_yojson.Basic.Decode.decoder = 
  (D.field "utc_timeonly_hour" int_decoder) >>= fun utc_timeonly_hour -> 
  (D.field "utc_timeonly_minute" int_decoder) >>= fun utc_timeonly_minute ->
  (D.field "utc_timeonly_second" int_decoder) >>= fun utc_timeonly_second ->                    
  D.maybe (D.field "utc_timeonly_microsec" int_decoder) >>= fun utc_timeonly_microsec ->     
  D.succeed {
    utc_timeonly_hour   
  ; utc_timeonly_minute  
  ; utc_timeonly_second
  ; utc_timeonly_microsec                           
  };;

let utctimeonly_micro_opt_to_json  = function
  | None    -> `Null
  | Some x  -> utctimeonly_micro_to_json x
;;

let week_to_json = function
  | Week_1 -> `String "Week1"
  | Week_2 -> `String "Week2"
  | Week_3 -> `String "Week3"
  | Week_4 -> `String "Week4"
  | Week_5 -> `String "Week5"
;;

let week_decoder : fix_week Decoders_yojson.Basic.Decode.decoder = 
  D.string >>= (fun w -> 
      match w with
      | "Week1" -> D.succeed (Week_1)
      | "Week2" -> D.succeed (Week_2)
      | "Week3" -> D.succeed (Week_3)
      | "Week4" -> D.succeed (Week_4)
      | "Week5" -> D.succeed (Week_5)
      | x -> D.fail (x^" is not a valid Week encoding."));;

let week_opt_to_json = function
  | None    -> `Null
  | Some x  -> week_to_json x
;;

let monthyear_to_json ( d : fix_monthyear) = 
  let list_assoc = [
    ( "monthyear_year"  , int_to_json       d.monthyear_year  );
    ( "monthyear_month" , int_to_json       d.monthyear_month );
    ( "monthyear_day"   , int_opt_to_json   d.monthyear_day   );
    ( "monthyear_week"  , week_opt_to_json  d.monthyear_week  );
  ] |> filter_nulls in
  `Assoc list_assoc
;;

let monthyear_decoder : fix_monthyear Decoders_yojson.Basic.Decode.decoder = 
  (D.field "monthyear_year" int_decoder) >>= fun monthyear_year -> 
  (D.field "monthyear_month" int_decoder) >>= fun monthyear_month ->
  D.maybe (D.field "monthyear_day" int_decoder) >>= fun monthyear_day ->    
  D.maybe (D.field "monthyear_week" week_decoder) >>= fun monthyear_week ->                         
  D.succeed {
    monthyear_year   
  ; monthyear_month  
  ; monthyear_day
  ; monthyear_week
  };;

let monthyear_opt_to_json = function
  | None    -> `Null
  | Some x  -> monthyear_to_json x
;;
[@@@logic]
