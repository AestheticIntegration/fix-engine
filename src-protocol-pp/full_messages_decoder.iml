(* Imandra Inc. copyright 2021 *)
[@@@program]
[@@@require "decoders-yojson"]
[@@@import "../src-protocol/full_messages.iml"]
[@@@import "full_admin_messages_decoder.iml"]
[@@@import "../src-protocol-exts-pp/full_app_messages_decoder.iml"]
[@@@import "../src-protocol/full_admin_tags.iml"]
[@@@import "full_message_tags_decoder.iml"]
[@@@import "full_admin_enums_decoder.iml"]
[@@@import "../src-core-time-defaults-pp/time_defaults_json.iml"]
open Full_app_messages_decoder;;
open Full_admin_messages_decoder;;
open Full_admin_tags;;
open Full_messages;;
open Full_message_tags_decoder;;
open Full_admin_enums_decoder;;
open Time_defaults_json;;

module D = Decoders_yojson.Basic.Decode;;

let full_msg_decoder : full_msg_data D.decoder = 
  let open D in 
  single_field @@ function
  | "Full_FIX_Admin_Msg" -> full_admin_msg_decoder >>= fun x -> 
    D.succeed (Full_FIX_Admin_Msg x) 
  | "Full_FIX_App_Msg" -> full_app_msg_of_json >>= fun x -> 
    D.succeed (Full_FIX_App_Msg x)
  | x -> D.fail @@ "Unknown full message type "^x
;;


let full_msg_reject_decoder : session_rejected_msg_data D.decoder = 
  let open D in 
  field "RefSeqNum" int >>= fun srej_msg_msg_seq_num -> 
  maybe (field "RefTagID" full_field_tag_of_json) >>= fun srej_msg_field_tag -> 
  maybe (field "RefMsgType" full_msg_tag_of_json) >>= fun srej_msg_msg_type -> 
  maybe (field "SessionRejectReason" full_admin_enum_fix_session_reject_reason_decoder) >>= fun srej_msg_reject_reason -> 
  maybe (field "Text" string) >>= fun srej_text -> 
  maybe (field "EncodedTextLen" int) >>= fun srej_encoded_text_len -> 
  maybe (field "EncodedText" string) >>= fun srej_encoded_text  -> 
  D.succeed 
    { srej_msg_msg_seq_num = Z.of_int srej_msg_msg_seq_num
    ; srej_msg_field_tag 
    ; srej_msg_msg_type
    ; srej_msg_reject_reason
    ; srej_text 
    ; srej_encoded_text_len = Option.map Z.of_int srej_encoded_text_len
    ; srej_encoded_text
    }
;;


let full_msg_business_reject_decoder : biz_rejected_msg_data D.decoder = 
  let open D in 
  field "RefSeqNum" int >>= fun brej_msg_ref_seq_num -> 
  field "RefMsgType" full_msg_tag_of_json >>= fun brej_msg_msg_tag   -> 
  maybe (field "BusinessFieldTag" full_field_tag_of_json) >>= fun brej_msg_field_tag -> 
  field "BusinessRejectReason" full_admin_enum_fix_business_reject_reason_decoder >>= 
  fun brej_msg_reject_reason -> 
  maybe (field "Text" string) >>= fun brej_msg_text -> 
  maybe (field "EncodedText" string) >>= fun brej_msg_encoded_text -> 
  D.succeed {
    brej_msg_ref_seq_num = Z.of_int brej_msg_ref_seq_num;
    brej_msg_msg_tag;
    brej_msg_reject_reason;
    brej_msg_field_tag;
    brej_msg_text;
    brej_msg_encoded_text;
  }
;;

let header_decoder : fix_header D.decoder = 
  let open D in 
  field "BeginString" string >>= fun h_begin_string -> 
  field "BodyLength" int >>= fun h_body_length -> 
  field "SenderCompID" string >>= fun h_sender_comp_id ->
  field "TargetCompID" string >>= fun h_target_comp_id ->
  field "MsgSeqNum" int >>= fun h_msg_seq_num -> 
  maybe (field "OnBehalfOfCompID" string) >>= fun h_on_behalf_of_comp_id -> 
  maybe (field "DeliverToCompID" string) >>= fun h_deliver_to_comp_id   -> 
  maybe (field "SecureDataLen" int) >>= fun h_secure_data_len -> 
  maybe (field "SecureData" int) >>= fun h_secure_data -> 
  maybe (field "SenderSubID" string) >>= fun h_sender_sub_id   ->    
  maybe (field "SenderLocationID" string) >>= fun h_sender_location_id ->  
  maybe (field "TargetSubID" string) >>= fun h_target_sub_id ->
  maybe (field "TargetLocationID" string) >>= fun h_target_location_id ->  
  maybe (field "OnBehalfOfSubID" string) >>= fun h_on_behalf_of_sub_id ->             
  maybe (field "OnBehalfOfLocationID" string) >>= fun h_on_behalf_of_location_id -> 
  maybe (field "DeliverToSubID" string) >>= fun h_deliver_to_sub_id ->    
  maybe (field "DeliverToLocationID" string) >>= fun h_deliver_to_location_id ->    
  maybe (field "PossDupFlag" bool) >>= fun h_poss_dup_flag ->     
  maybe (field "PossResend" bool) >>= fun h_poss_resend ->     
  field "SendingTime" utctimestamp_decoder >>= fun h_sending_time ->  
  maybe (field "OrigSendingTime" utctimestamp_decoder) >>= fun h_orig_sending_time -> 
  maybe (field "XmlDataLen" int) >>= fun h_xml_data_len ->  
  maybe (field "XmlData" int) >>= fun h_xml_data ->  
  maybe (field "MessageEncoding" int) >>= fun h_message_enconding ->  
  maybe (field "LastMsgSeqNumProcessed" int) >>= fun h_last_msg_seq_num_processed -> 
  maybe (field "NoHops" int) >>= fun h_no_hops -> 
  D.succeed {
    h_begin_string
  ; h_body_length = Z.of_int h_body_length
  ; h_sender_comp_id
  ; h_target_comp_id
  ; h_msg_seq_num = Z.of_int h_msg_seq_num
  ; h_on_behalf_of_comp_id
  ; h_deliver_to_comp_id
  ; h_secure_data_len = Option.map Z.of_int h_secure_data_len
  ; h_secure_data = Option.map Z.of_int h_secure_data
  ; h_sender_sub_id
  ; h_sender_location_id
  ; h_target_sub_id
  ; h_target_location_id
  ; h_on_behalf_of_sub_id
  ; h_on_behalf_of_location_id
  ; h_deliver_to_sub_id
  ; h_deliver_to_location_id
  ; h_poss_dup_flag
  ; h_poss_resend
  ; h_sending_time
  ; h_orig_sending_time
  ; h_xml_data_len = Option.map Z.of_int h_xml_data_len
  ; h_xml_data = Option.map Z.of_int h_xml_data
  ; h_message_encoding = Option.map Z.of_int h_message_enconding
  ; h_last_msg_seq_num_processed = Option.map Z.of_int h_last_msg_seq_num_processed
  ; h_no_hops = Option.map Z.of_int h_no_hops
  }
;;

let trailer_decoder : fix_trailer D.decoder = 
  let open D in 
  maybe (field "SignatureLength" int) >>= fun signature_length -> 
  maybe (field "Signature" int) >>= fun signature -> 
  field "CheckSum" int >>= fun check_sum -> 
  D.succeed {
    signature_length = Option.map Z.of_int signature_length
  ; signature = Option.map Z.of_int signature
  ; check_sum = Z.of_int check_sum
  }
;;

let full_valid_msg_decoder : full_valid_fix_msg D.decoder = 
  let open D in 
  field "StandardHeader" header_decoder >>= fun full_msg_header -> 
  field "MessageBody" full_msg_decoder >>= fun full_msg_data -> 
  field "StandardTrailer" trailer_decoder >>= fun full_msg_trailer -> 
  D.succeed {
    full_msg_header
  ; full_msg_data
  ; full_msg_trailer
  }
;;

let full_valid_msg_list_decoder : full_valid_fix_msg list D.decoder = 
  let open D in 
  list full_valid_msg_decoder
;;

let full_top_level_msg_decoder : full_top_level_msg D.decoder = 
  let open D in 
  single_field @@ function
  | "ValidMsg" -> full_valid_msg_decoder >>= fun m -> 
    D.succeed (ValidMsg m) 
  | "SessionRejectedMsg" -> full_msg_reject_decoder >>= fun m -> 
    D.succeed (SessionRejectedMsg m)
  | "BusinessRejectedMsg" -> full_msg_business_reject_decoder >>= fun m -> 
    D.succeed (BusinessRejectedMsg m)
  | "Garbled" -> string >>= fun m -> 
    D.succeed Garbled
  | x -> D.fail @@ "unknown top level message "^x

;;

[@@@logic]