<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parser (fix-engine.Parser_utils.Parser)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">fix-engine</a> &#x00BB; <a href="../index.html">Parser_utils</a> &#x00BB; Parser</nav><h1>Module <code>Parser_utils.Parser</code></h1><p>The Parser module collects an API of parser-combinators for parsing FIX messages into OCaml types. Each combinator takes a continuation function that returns a <code>( 'a Parser.t * msg )</code> type</p></header><dl><dt class="spec type" id="type-msg"><a href="#type-msg" class="anchor"></a><code><span class="keyword">type </span>msg</code><code><span class="keyword"> = </span>(Imandra_prelude.string<span class="keyword"> * </span>Imandra_prelude.string) list</code></dt><dd><p>Type alias for a FIX message -- we assyme it is a list of string parirs</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>'a t</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-t.ParseSuccess" class="anchored"><td class="def constructor"><a href="#type-t.ParseSuccess" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">ParseSuccess</span><span class="keyword"> of </span><span class="type-var">'a</span></code></td></tr><tr id="type-t.UnknownMessageTag" class="anchored"><td class="def constructor"><a href="#type-t.UnknownMessageTag" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">UnknownMessageTag</span><span class="keyword"> of </span>Imandra_prelude.string</code></td></tr><tr id="type-t.RequiredTagMissing" class="anchored"><td class="def constructor"><a href="#type-t.RequiredTagMissing" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">RequiredTagMissing</span><span class="keyword"> of </span>Imandra_prelude.string</code></td></tr><tr id="type-t.DuplicateTag" class="anchored"><td class="def constructor"><a href="#type-t.DuplicateTag" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">DuplicateTag</span><span class="keyword"> of </span>Imandra_prelude.string</code></td></tr><tr id="type-t.WrongValueFormat" class="anchored"><td class="def constructor"><a href="#type-t.WrongValueFormat" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">WrongValueFormat</span><span class="keyword"> of </span>Imandra_prelude.string</code></td></tr><tr id="type-t.UndefinedTag" class="anchored"><td class="def constructor"><a href="#type-t.UndefinedTag" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">UndefinedTag</span><span class="keyword"> of </span>Imandra_prelude.string</code></td></tr><tr id="type-t.EmptyValue" class="anchored"><td class="def constructor"><a href="#type-t.EmptyValue" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">EmptyValue</span><span class="keyword"> of </span>Imandra_prelude.string</code></td></tr><tr id="type-t.IncorrectNumInGroupCount" class="anchored"><td class="def constructor"><a href="#type-t.IncorrectNumInGroupCount" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">IncorrectNumInGroupCount</span><span class="keyword"> of </span>Imandra_prelude.string</code></td></tr><tr id="type-t.RepeatingGroupOutOfOrder" class="anchored"><td class="def constructor"><a href="#type-t.RepeatingGroupOutOfOrder" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">RepeatingGroupOutOfOrder</span><span class="keyword"> of </span>Imandra_prelude.string</code></td></tr><tr id="type-t.GarbledMessage" class="anchored"><td class="def constructor"><a href="#type-t.GarbledMessage" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">GarbledMessage</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val </span>(&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>A standard monadic bind operator for the Parser.t type</p></dd></dl><dl><dt class="spec value" id="val-(&gt;|&gt;=)"><a href="#val-(&gt;|&gt;=)" class="anchor"></a><code><span class="keyword">val </span>(&gt;|&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'c</span> list) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'c</span> list</code></dt><dd><p>The modified bind operator that applies a function that returns <code>( 'a Parser.t * msg )</code> pair</p></dd></dl><dl><dt class="spec value" id="val-rev_collect"><a href="#val-rev_collect" class="anchor"></a><code><span class="keyword">val </span>rev_collect : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p>A &quot;collect&quot; function that convers <code>'a t list -&gt; 'a list t</code> Note: Tail-recursive, but reverses the list.</p></dd></dl><aside><p>Parser combinators.</p></aside><aside><p>Each combinator takes the current message as the first argument and the continuation function as the last argument.</p><p>A typical message parser would look like this.</p><pre><code class="ml">let parse_message msg = (
  repeating msg &quot;1&quot; parse_rg @@ fun msg group -&gt;
  check_duplicate_tags msg   @@ fun () -&gt;
  block     msg parse_blk    @@ fun msg block -&gt;
  req msg &quot;2&quot; parse_int      @@ fun msg x -&gt; 
  opt msg &quot;3&quot; parse_string   @@ fun msg y -&gt; 
  req msg &quot;4&quot; parse_int      @@ fun msg z -&gt; 
  ParseSuccess \{ block; group; x; y; z \}, msg 
) |&gt; check_unknown_tags </code></pre></aside><dl><dt class="spec value" id="val-opt"><a href="#val-opt" class="anchor"></a><code><span class="keyword">val </span>opt : (Imandra_prelude.string<span class="keyword"> * </span>Imandra_prelude.string) list <span>&#45;&gt;</span> Imandra_prelude.string <span>&#45;&gt;</span> (Imandra_prelude.string <span>&#45;&gt;</span> <span class="type-var">'a</span> option) <span>&#45;&gt;</span> ((Imandra_prelude.string<span class="keyword"> * </span>Imandra_prelude.string) list <span>&#45;&gt;</span> <span class="type-var">'a</span> option <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'c</span> list) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'c</span> list</code></dt><dd><p>Optional field combinator, passes None into continuation if the tag is not present</p></dd></dl><dl><dt class="spec value" id="val-req"><a href="#val-req" class="anchor"></a><code><span class="keyword">val </span>req : (Imandra_prelude.string<span class="keyword"> * </span>Imandra_prelude.string) list <span>&#45;&gt;</span> Imandra_prelude.string <span>&#45;&gt;</span> (Imandra_prelude.string <span>&#45;&gt;</span> <span class="type-var">'a</span> option) <span>&#45;&gt;</span> ((Imandra_prelude.string<span class="keyword"> * </span>Imandra_prelude.string) list <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'c</span> list) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'c</span> list</code></dt><dd><p>Required field combinator, returns RequiredTagMissing if the tag is not present</p></dd></dl><dl><dt class="spec value" id="val-block"><a href="#val-block" class="anchor"></a><code><span class="keyword">val </span>block : <a href="index.html#type-msg">msg</a> <span>&#45;&gt;</span> (<a href="index.html#type-msg">msg</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a>) <span>&#45;&gt;</span> (<a href="index.html#type-msg">msg</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a></code></dt><dd><p>Block parser combinator parsers a record and passes it into the continuation</p></dd></dl><dl><dt class="spec value" id="val-repeating"><a href="#val-repeating" class="anchor"></a><code><span class="keyword">val </span>repeating : <a href="index.html#type-msg">msg</a> <span>&#45;&gt;</span> Imandra_prelude.string <span>&#45;&gt;</span> (<a href="index.html#type-msg">msg</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a>) <span>&#45;&gt;</span> (<a href="index.html#type-msg">msg</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a></code></dt><dd><p>Repeating group parser combinator, starting from the tag that encodes the length of the list, identifies the subgroups and passes each of them into the block parser. Performs a number of consistency checks on the parsed results.</p></dd></dl><dl><dt class="spec value" id="val-check_duplicate_tags"><a href="#val-check_duplicate_tags" class="anchor"></a><code><span class="keyword">val </span>check_duplicate_tags : <a href="index.html#type-msg">msg</a> <span>&#45;&gt;</span> (Imandra_prelude.unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a></code></dt><dd><p>Checks for duplicate tags in messages -- should be called after all the repeating groups are porcessed</p></dd></dl><dl><dt class="spec value" id="val-check_unknown_tags"><a href="#val-check_unknown_tags" class="anchor"></a><code><span class="keyword">val </span>check_unknown_tags : (<span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span>(Imandra_prelude.string<span class="keyword"> * </span><span class="type-var">'b</span>) list) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>This finalizes the message -- if there are any unplrocessed tag=value pairs left -- we return an error</p></dd></dl><dl><dt class="spec value" id="val-get_top_and_last"><a href="#val-get_top_and_last" class="anchor"></a><code><span class="keyword">val </span>get_top_and_last : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list<span class="keyword"> * </span><span class="type-var">'a</span> option</code></dt><dt class="spec value" id="val-list_to_split"><a href="#val-list_to_split" class="anchor"></a><code><span class="keyword">val </span>list_to_split : Imandra_prelude.string list <span>&#45;&gt;</span> char <span>&#45;&gt;</span> Imandra_prelude.string</code></dt><dt class="spec value" id="val-split_to_list"><a href="#val-split_to_list" class="anchor"></a><code><span class="keyword">val </span>split_to_list : Imandra_prelude.string <span>&#45;&gt;</span> char <span>&#45;&gt;</span> Imandra_prelude.string list</code></dt></dl></div></body></html>