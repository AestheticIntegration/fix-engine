(** 

    Aesthetic Integration Limited
    Copyright 2014 - 2017

    basic_model_iml.ml

    
*)

(** 
    The order of various dependencies:
    -- core types
    -- messages 
    -- state definition

    | CreateOrderSingle of create_order_data
    | OrderCancelRequest of request_data 
    | ExecutionReport of exec_report_data
    | CancelReject of cancel_reject
*)

type create_order_data = {
    order_qty   : int;
    limit_price : int;
};;

type exec_report_data = {
    fill_qty    : int;
    price_qty   : int;
};;

type cancel_replace_request_data = {
    ord_id      : int;
};;

type cancel_reject = {
    ord_id      : int;
};;

type fix_msg = 
    | CreateOrderSingle of create_order_data
    | OrderCancelRequest of request_data 
    | ExecutionReport of exec_report_data
    | CancelReject of cancel_reject
;;

(* Venue state definitions. *)
type state_type = {
    hello   : int;              (*  *)
    one     : int;              (*  *)
    two     : int;              (*  *)
};;

(*** Generated - from default values of 'state' ***)
let state_type_initial = {
    hello   = 0;
    one     = 0;
    two     = 0; 
};;


(* The true state of the model. *)
type model_state = {

    (** auto-generated *)
    state : state_type;

    (** messages that would be sent out  *)
    outgoing_fix_msgs : fix_msg list;

    (**  *)
}

(** ************************************************************************************ *)
(* Is message incoming?                                                                  *)
(** ************************************************************************************ *)
let is_msg_incoming ( msg : fix_msg ) =
    match msg with 
    | CreateOrderSingle _   -> true
    | OrderCancelRequest _  -> true
    | _                     -> false
;;

(** ************************************************************************************ *)
(* Is message outgoing?                                                                  *)
(** ************************************************************************************ *)
let is_msg_outgoing ( msg : fix_msg ) = 
    match msg with
    | ExecutionReport _     -> true
    | CancelReject _        -> true
    | _                     -> false
;;
(** ************************************************************************************ *)


(** ************************************************************************************ *)
(* Check that all of the required fields are present.                                    *)
(** ************************************************************************************ *)

(* Generate these for 'incoming messages' *)

(* Also, should generate these for 'outgoing messages' *)

(* CreateOrderSingle *)
let check_fields_CreateOrderSingle ( cos_data : create_order_data ) =
    if is_missing_field_one (cos_data.field_one) then {
        field_is_missing = true;
        missing_field = field_one;
    } else if is_missing_field_two (cos_data.field_two) then {
        field_is_missing = true;
        missing_field = field_two;
    } else if is_missing_field_three (cost_data.field_three) then {
        field_is_missing = true;
        missing_field = field_two;
    } else {
        field_is_missing = false;
        missing_field = None;
    }
;;

(* OrderCancelReplaceRequest *)
let check_fields_OrderCancelReplaceRequest ( er_data : exec_report_data ) =
    if is_missing_field_one ( er_data.field_one ) then {
        field_is_missing = true;
        missing_field = Some field_one;
    } else if is_missing_field_one ( er_data.field_two ) then {
        field_is_missing = true;
        missing_field = Some field_two
    } else {
        field_is_missing = false;
        missing_field = None;
    }
;;
(** ************************************************************************************ *)


(** ************************************************************************************ *)
(** Save incoming data to the internal state. *)

let save_data_CreateOrderSingle ( data, state : create_order_data * internal_data_state ) = {
    state with 
        field_one = data.field_one;
        field_two = data.field_two;
};;

(** *)
let save_data_ExecutionReport ( data, state : exec_report_data * internal_data_state ) = { 
    state with
        field_one = data.field_one;
        field_two = data.field_two;
};;

let save_incoming_data ( msg, state : fix_msg * internal_state ) =
    match msg with 
    | CreateOrderSingle data    -> save_data_CreateOrderSingle (data, state)
    | ExecutionReport data      -> save_data_ExecutionReport (data, state)
    | OrderCancelRequest data   -> save_data_OrderCancelRequest (data, state)
    | CancelReject data         -> save_data_OrderCancelRequest (data, state)
;; 
(** ************************************************************************************ *)

(** ************************************************************************************ *)
(** Generated by the DSL                                                                 *)
(** ************************************************************************************ *)
let check_all_fields_present ( msg : FIXMsg ) = 
    match msg with 
    | CreateOrderSingle data    -> check_fields_CreateOrderSingle (data)
    | ExecutionReport data      -> check_fields_ExecutionReport (data)
    | OrderCancelRequest data   -> check_fields_OrderCancelRequest (data)
    | CancelReject data         -> check_fields_CancelReject (data)
;;

(** ************************************************************************************ *)

(** Send message -> NOT GENERATED *)
let send_msg ( msg, state ) =  {
    state with 
        outgoing_msgs = msg :: state.outgoing_msgs
};;

let send_out_field_reject ( msg, missing_field_info, state ) =
    match msg with 
    | CreateOrderSingle data    -> true
    | ExecutionReport data      -> true
;;

let send_out_field_invalid_reject ( msg, invalid_field, state :  ) =
    match msg with
    | CreateOrderSingle data    -> true
    | ExecutionReport data      -> true
;;

let send_out_msg_invalid_reject ( msg, invalid_field ) = 
    match msg with 
    | CreateOrderSingle data    -> true
    | ExecutionReport data      -> true
;;

let check_fields_valid_CreateOrderSingle ( msg ) =
    false
;;

let check_fields_valid_ExecutionReport ( msg ) =
    false
;;

(** ************************************************************************************ *)
(** Reject handlers - auto-generated *)
(** ************************************************************************************ *)

let reject_field_CreateOrderSingle ( data, reject_event, state ) =
    state
;;

let reject_field_OrderCancelRequest ( data, reject_event, state ) =
    state
;;

let reject_field_ExecutionReport ( data, reject_event, state) =
    state
;;

let reject_field_CancelReject ( data, reject_event, state) =
    state
;;

(** ************************************************************************************ *)
let reject_custom_CreateOrderSingle ( data, reject_enum, state) =
    state
;;

let reject_custom_OrderCancelRequest (data, reject_enum, state) =
    state
;;

let reject_custom_ExecutionReport (data, reject_enum, state) =
    state
;;

let reject_custom_CancelReject (data, reject_enum, state) =
    state
;;

(** ************************************************************************************ *)

(**

    Fields of an internal state are not optional. All fields of a message are optional (in OCaml sense).



    ---- Message Declarations ----

    (** Two assignment functions for each message type that's used. *)


    (* For this assignment to work, we need to have default message data values that would be used as default ones *)

    (* List all of the fields here with None's *)
    let init_CreateOrderSingle = {
        field_one = None;
        field_two = None;
        field_three = None;
        field_four = None;
        field_five = None;
        field_six = None;
    };;

    (** For all of these fields that have the same name and type, this would be created *)
    let assign_to_state_CreateOrderSingle ( msg_data : create_order_single_data ) = {
        state with 
            field_one = match msg_data.field_one with 
                | None -> state.field_one
                | Some x -> msg_data.field_one;
            field_two = match msg_data.field_two with
                | None -> state.field_two
                | Some x -> msg_data.field_two;
    }
    ;;

    (* If a message has no fields with same name/type as the state, then the default message 
        would be returned istead.  *)


    let assign_to_msg_CreateOrderSingle ( state ) = {
        init_CreateOrderSingle with {
            field_one = Some state.field_one;
            field_two = Some state.field_two;
            field_three = Some state.field_three;
        }
    }



    ---- Message Declarations ---- 


    Requirement maps

    Each field of a message may have a flag that says it's required 'req' or 'required', or 
    otherwise it may say 'opt' (or 'optional' or completely leave it out), 

    Consider an example where we require 3 fields to be present and the rest are optional:

    """
    message CreateNewOrder {
        opt Price
        req Limit
        req OrdType 
        req Symbol
        opt SymbolFx 
        opt OrderQty
        Currency
    }
    """

    We would generate the following requirements map for this message type:

    """
    let check_field_req_CreateNewOrder ( field : fix_field ) =
        match field with 
        | Price 
        | Limit 
        | Symbol -> true
        | _      -> false
    ;; """

    Note that we're mapping from all of the fields - this type is a subset of all the FIX
    fields, it includes only those fields that we have as part of the 

    ---- Field Validators ---- 

    For each field, create a validator function... 

    The fundamental issue is that each message field is translated into an optional type in 
    OCaml -> this allows us to have 'opt' vs 'req' fields. Downside of this is that we need
    to handle all of None cases and create requirement maps as listed above.

    So, a statement like this:

    'opt Price valid when it > Price(0.0) and it < Price (100000.0)' would generate the following

    validity check:
    """ 
    let msg_field_validity_CreateNewSingle_Price ( data, state ) =
        match data.field_Price with 
            | None -> true
            | Some field_Price_data -> field_Price_data > 0 && field_Price_data < 100000;; """
    
    i.e. if the field is missing -> this would return 'true' as in it's valid - would not 
    produce a Reject message back.

    If, instead, we have change the requirement:
    'req Price valid when it > Price (0.0) and it < Price (100000.0)'. We would still have 
    the same validity check, but the requirements map would be different (see the example above). Since the requirement
    map is the first one that is checked - we would never get to this validator when a real 
    message with the missing field (and 'req' prefix) would show up.


    ---- Complex validity ----


    'message' declarations may include 'validate' statements that may reference multiple fields

    'validate { this.Price > Price(10.0) && this.Currency = GBP } reject with PriceTooLow'

    This would translate to the following:

    """
    let msg_validate_CreateNewSingle_1 ( data, state ) =
        match data.field_Price with
        | None -> true
        | Some field_Price_data ->
            match data.field_Currency with 
            | None -> true
            | Some field_Currency_data -> (field_Price_data < 100000.00 && field_Currency_data = GBP);; """

    Because all of the fields are optional, we need to extract these definitions and return 'true'
    if any one of them is missing. The code generating algorithm should traverse all field references
    and create these nested 'match' structures for their set - i.e. ensure if the field is referenced
    twice, it does not produce 2 match statements.


    ---- Encoding Conditional Requirements ----

    There are situations when a field may be required but conditionally on either some field missing
    or having some value. For this, we have two special functions, 'present' and 'absent' that take 
    name of a field that has been referenced and return a boolean.

    Consider the following case: 

    'validate { present (this.Price) && this.OrderType == Limit } reject with LimitPriceMissing'

    'validate { absent (this.Price) || present (this.OrderPrice) } reject with SomeReason'

    We would generate the following custom validity check:


    """
    let msg_validate_CreateNewSingle_2 ( data, state ) = 
        

    ;;
    
    """

    ----->>>> Reject and Receive Functions <<<<-----

    ---- Auto-message assignment ---- 




    The special purpose of these functions is that they are effectively the only places that process
    incoming and send out outgoing messages. 

    Most often, the fields of these messages would mirror those fields of the 


    ---- Encoding Reject Functions - Field ----

    '
    reject ( msg : CreateNewSingle, field : Field) {

        send ExecutionReport with {
            Reason = toText (field)
        }

    }'


    ---- Encoding Reject Functions - Custom ----

    '
    reject ( msg : OrderCancelReplaceRequest, val : CustomEnum ) {

        send CancelReject with {
            Reason = val
        }

    }'
    
    ' reject ( msg : CreateNewSingle, val : CustomEnum ) {

        send ExecutionReport with {
            Reason = val
            ExecType = Reject
        }
    }'

    ---- Encoding Receive Functions - Messages ----

    'receive' functions allow user to encode precise state transition in case incoming message
    fully satisfies the requirements (passes the validity checks and contains all required fields).


    Consider the following example:

    'receive (msg : CreateOrderSingle) {
        state.order_received = true

        send ExecutionReport with {

        }
    }'


    ---- Encoding Receive Functions - Actions ----

    Actions represent state transitions due to interaction of client's orders with the rest of the application. 



    Process an incoming fill action by updating internal information and secing

    'receive (fill : Fill) {

        /* Need to update the information for it.  */

        send ExecutionReport with {
            ExecType = Fill
        }

    }'

    'receive (tc : TimeChange) {
        state.current_time = tc.time_now

        /* If the order has expired, then change status and send out the ExecutionReport for it */
        if (state.current_time > state.closing_time) {
            state.OrdStatus = Cancelled;
            send ExecutionReport with {
                OrdStatus = Cancelled;
                ExecType = Cancelled;
            }
        }
    }'


 *)


let check_fields_valid_CreateOrderSingle ( data, state :  ) =
    (* valid when it > Price(0.0) and it < Price (100000.0) *)
    match data.field_Price with 
    | None -> true
    | Some field_Price_data -> field_Price_data > 0 && field_Price_data < 100000

;;


let 

(** ************************************************************************************ *)


(** process_field_reject: *)
let process_field_reject ( originating_msg, reject_event, state : fix_msg * reject_event * internal_data_state ) =
    match originating_msg with 
    | CreateOrderSingle data    -> reject_field_CreateOrderSingle ( data, state, reject_event )
    | OrderCancelRequest data   -> reject_field_OrderCancelRequest ( data, state, reject_event )
    | ExecutionReport data      -> reject_field_ExecutionReport ( data, state, reject_event )
    | CancelReject data         -> reject_field_CancelReject ( data, state, reject_event )
;;

(** process_custom_reject: how do we process this??? *)
let process_custom_reject ( originating_msg, reason, state : fix_msg * gen_customReject * internal_data_state ) =
    match originating_msg with 
    | CreateOrderSingle data    -> reject_custom_CreateOrderSingle ( data, state, reject_enum )
    | OrderCancelRequest data   -> reject_custom_OrderCancelRequest (data, state, reject_enum )
    | ExecutionReport data      -> reject_custom_ExecutionReport (data, state, reject_enum )
    | CancelReject data         -> reject_custom_CancelReject (data, state, reject_enum )
;;

(** ************************************************************************************ *)

(** ************************************************************************************ *)

(** field_invalid -> will create a rejection event that would need to be handled later *)
let field_invalid ( msg ) =
    match msg with
    | CreateOrderSingle data    -> check_fields_valid_CreateOrderSingle (data)
    | OrderCancelRequest data   -> check_fields_valid_OrderCancelRequest (data)
    | ExecutionReport data      -> check_fields_valid_ExecutionReport (data)
    | CancelReject data         -> check_fields_valid_CancelReject (data)
;;

(** ************************************************************************************ *)
(* The main function: one_step : fix_msg * internal_data_state -> internal_data_state    *)
(** ************************************************************************************ *)
let one_step ( msg, state : fix_msg * internal_data_state ) =

    (* Check that all fields are present... *)
    let missing_field_info = check_all_fields_present (msg) in

    if missing_field_info.field_is_missing then
        (* Generate outgoing rejection message for this... *)
        send_out_field_reject ( msg, missing_field_info ) else

    let field_invalid ( msg ) in

    state
;;
(** ************************************************************************************ *)