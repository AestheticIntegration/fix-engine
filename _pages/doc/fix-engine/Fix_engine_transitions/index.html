<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fix_engine_transitions (fix-engine.Fix_engine_transitions)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">fix-engine</a> &#x00BB; Fix_engine_transitions</nav><h1>Module <code>Fix_engine_transitions</code></h1><p>FIX 4.4 engine transition functions.</p></header><dl><dt class="spec value" id="val-logoff_and_shutdown"><a href="#val-logoff_and_shutdown" class="anchor"></a><code><span class="keyword">val </span>logoff_and_shutdown : <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a> <span>&#45;&gt;</span> <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a></code></dt><dd><p>In many abnormal cases we need to send out the Logout messages and transition to ShutdownInitiated state.</p></dd></dl><dl><dt class="spec value" id="val-make_resend_message"><a href="#val-make_resend_message" class="anchor"></a><code><span class="keyword">val </span>make_resend_message : (<a href="../Full_messages/index.html#type-full_valid_fix_msg">Full_messages.full_valid_fix_msg</a><span class="keyword"> * </span><a href="../TimeDefaults/index.html#type-fix_utctimestamp">TimeDefaults.fix_utctimestamp</a><span class="keyword"> * </span>Imandra_prelude.int) <span>&#45;&gt;</span> <a href="../Full_messages/index.html#type-full_valid_fix_msg">Full_messages.full_valid_fix_msg</a></code></dt><dd><p>Before sending out a historic message, we need to:</p><ul><li>move the sequence number if it is too low</li><li>set PossibleDuplicate flag</li><li>move historic SendingTime to OrigSendingTime</li><li>update SendingTime</li></ul></dd></dl><dl><dt class="spec value" id="val-run_retransmit"><a href="#val-run_retransmit" class="anchor"></a><code><span class="keyword">val </span>run_retransmit : <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a> <span>&#45;&gt;</span> <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a></code></dt><dd><p>We're in the middle of retransmitting historic messages. Note: when we transition into Retransmit mode, we set up a queue with messages that should be sent out. These messages are a function of the parameters that were sent to the engine.</p></dd></dl><dl><dt class="spec value" id="val-run_no_active_session"><a href="#val-run_no_active_session" class="anchor"></a><code><span class="keyword">val </span>run_no_active_session : (<a href="../Full_messages/index.html#type-full_valid_fix_msg">Full_messages.full_valid_fix_msg</a><span class="keyword"> * </span><a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a>) <span>&#45;&gt;</span> <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a></code></dt><dd><p>Here we will only accept an incoming Logon message to establish a connection.</p></dd></dl><dl><dt class="spec value" id="val-run_logon_sequence"><a href="#val-run_logon_sequence" class="anchor"></a><code><span class="keyword">val </span>run_logon_sequence : (<a href="../Full_messages/index.html#type-full_valid_fix_msg">Full_messages.full_valid_fix_msg</a><span class="keyword"> * </span><a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a>) <span>&#45;&gt;</span> <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a></code></dt><dt class="spec value" id="val-initiate_Resend"><a href="#val-initiate_Resend" class="anchor"></a><code><span class="keyword">val </span>initiate_Resend : (<a href="../Fix_engine_state/index.html#type-fix_engine_mode">Fix_engine_state.fix_engine_mode</a><span class="keyword"> * </span><a href="../Full_admin_messages/index.html#type-full_msg_resend_request_data">Full_admin_messages.full_msg_resend_request_data</a><span class="keyword"> * </span><a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a>) <span>&#45;&gt;</span> <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a></code></dt><dd><p>Response to resend request. Note that we're copyng over the whole list of historic messages - we will use the starting/ending indexes to ensure we're only sending out the right ones. Perhaps there's a better way to do this - it's important that we always maintain the spirit of 'one_step' - all operations are are atomic.</p></dd></dl><dl><dt class="spec value" id="val-attempt_sequence_reset"><a href="#val-attempt_sequence_reset" class="anchor"></a><code><span class="keyword">val </span>attempt_sequence_reset : (<a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a><span class="keyword"> * </span>Imandra_prelude.int<span class="keyword"> * </span>Imandra_prelude.int) <span>&#45;&gt;</span> <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a></code></dt><dt class="spec value" id="val-run_active_session"><a href="#val-run_active_session" class="anchor"></a><code><span class="keyword">val </span>run_active_session : (<a href="../Full_messages/index.html#type-full_valid_fix_msg">Full_messages.full_valid_fix_msg</a><span class="keyword"> * </span><a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a>) <span>&#45;&gt;</span> <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a></code></dt><dd><p>We're operating in a normal mode.</p></dd></dl><dl><dt class="spec value" id="val-run_wait_heartbeat"><a href="#val-run_wait_heartbeat" class="anchor"></a><code><span class="keyword">val </span>run_wait_heartbeat : (<a href="../Full_messages/index.html#type-full_valid_fix_msg">Full_messages.full_valid_fix_msg</a><span class="keyword"> * </span><a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a>) <span>&#45;&gt;</span> <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a></code></dt><dd><p>We've force-requested a heartbeat message from the other end and waiting for it to come. TODO: We're ignoring all other messages -- check the specs if that is a correct behavior</p></dd></dl><dl><dt class="spec value" id="val-run_gap_detected"><a href="#val-run_gap_detected" class="anchor"></a><code><span class="keyword">val </span>run_gap_detected : <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a> <span>&#45;&gt;</span> <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a></code></dt><dd><p>We're in a GapDetected state. Sending out resend request and transitioning into Recovery.</p></dd></dl><dl><dt class="spec value" id="val-replay_single_msg"><a href="#val-replay_single_msg" class="anchor"></a><code><span class="keyword">val </span>replay_single_msg : (<a href="../Full_messages/index.html#type-full_valid_fix_msg">Full_messages.full_valid_fix_msg</a><span class="keyword"> * </span><a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a>) <span>&#45;&gt;</span> <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a></code></dt><dd><p>Here we can only handle a subset of the FIX messages.</p></dd></dl><dl><dt class="spec value" id="val-run_cache_replay"><a href="#val-run_cache_replay" class="anchor"></a><code><span class="keyword">val </span>run_cache_replay : <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a> <span>&#45;&gt;</span> <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a></code></dt><dd><p>Run the engine through the replay messages. This is used during recovery.</p><p>Note that the only session-level message we should receive at this point should be a Reject message. We need to ensure that this function cannot lead to another Recovery state.</p></dd></dl><dl><dt class="spec value" id="val-no_seq_gaps"><a href="#val-no_seq_gaps" class="anchor"></a><code><span class="keyword">val </span>no_seq_gaps : (<a href="../Full_messages/index.html#type-full_valid_fix_msg">Full_messages.full_valid_fix_msg</a> list<span class="keyword"> * </span>Imandra_prelude.int) <span>&#45;&gt;</span> bool</code></dt><dd><p>Check to make sure there're no sequence gaps</p></dd></dl><dl><dt class="spec value" id="val-is_cache_complete"><a href="#val-is_cache_complete" class="anchor"></a><code><span class="keyword">val </span>is_cache_complete : (<a href="../Full_messages/index.html#type-full_valid_fix_msg">Full_messages.full_valid_fix_msg</a> list<span class="keyword"> * </span>Imandra_prelude.int) <span>&#45;&gt;</span> bool</code></dt><dd><p>Is cache valid so that we can transition from recovery?</p><p>Cache is considered valid when: 1. It is non-empty 2. The sequence IDs of the messages within cache are continuous (i.e. there're no gaps) 3. First sequence ID (of the cache) is next message from the last one correctly processed.</p></dd></dl><dl><dt class="spec value" id="val-add_to_cache"><a href="#val-add_to_cache" class="anchor"></a><code><span class="keyword">val </span>add_to_cache : (<a href="../Full_messages/index.html#type-full_valid_fix_msg">Full_messages.full_valid_fix_msg</a><span class="keyword"> * </span><a href="../Full_messages/index.html#type-full_valid_fix_msg">Full_messages.full_valid_fix_msg</a> list) <span>&#45;&gt;</span> <a href="../Full_messages/index.html#type-full_valid_fix_msg">Full_messages.full_valid_fix_msg</a> list</code></dt><dd><p>Add message to cache so that ordering is maintained.</p></dd></dl><dl><dt class="spec value" id="val-run_recovery"><a href="#val-run_recovery" class="anchor"></a><code><span class="keyword">val </span>run_recovery : (<a href="../Full_messages/index.html#type-full_valid_fix_msg">Full_messages.full_valid_fix_msg</a><span class="keyword"> * </span><a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a>) <span>&#45;&gt;</span> <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a></code></dt><dd><p>We're in recovery mode. Logoff and ResendRequest messages must be processed. We should add any other received messages are addted to the cache. Transition to CacheReplay when the cahce is complete.</p></dd></dl><dl><dt class="spec value" id="val-run_shutdown"><a href="#val-run_shutdown" class="anchor"></a><code><span class="keyword">val </span>run_shutdown : (<a href="../Full_messages/index.html#type-full_valid_fix_msg">Full_messages.full_valid_fix_msg</a><span class="keyword"> * </span><a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a>) <span>&#45;&gt;</span> <a href="../Fix_engine_state/index.html#type-fix_engine_state">Fix_engine_state.fix_engine_state</a></code></dt><dd><p>We've sent out a Logout message and are now waiting for a confirmation of logout.</p></dd></dl></div></body></html>