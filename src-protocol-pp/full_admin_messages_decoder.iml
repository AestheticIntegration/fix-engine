(* Imandra Inc. copyright 2021 *)
[@@@program]
[@@@import "../src-core-pp/base_types_json.iml"]
open Base_types_json;;
[@@@import "../src-core-pp/datetime_json.iml"]
open Datetime_json;;
[@@@import "full_admin_enums_decoder.iml"]
open Full_admin_enums_decoder;;
[@@@import "../src-protocol/full_admin_messages.iml"]
open Full_admin_messages;;
[@@@import "full_message_tags_decoder.iml"]
open Full_message_tags_decoder;;

module D = Decoders_yojson.Basic.Decode;;

let full_msg_heartbeat_decoder  : full_msg_heartbeat_data D.decoder =
  let open D in
  maybe @@ field "TestReqID" string >>= fun hb_test_req_id ->
  D.succeed {hb_test_req_id}
;;


let full_msg_types_inner_rg_decoder  : full_msg_types_inner_rg D.decoder =
  let open D in
  field "mtps_ref_msg_type" full_msg_tag_of_json >>= fun mtps_ref_msg_type -> 
  field "mtps_direction" full_admin_enum_fix_msgdirection_decoder >>= fun mtps_direction -> 
  D.succeed {mtps_ref_msg_type;mtps_direction}
;;

let full_msg_logon_decoder : full_msg_logon_data D.decoder = 
  let open D in 
  field "EncryptMethod" full_admin_enum_fix_encryption_method_decoder >>= fun ln_encrypt_method ->
  field "HeartBtInt" duration_decoder >>= fun ln_heartbeat_interval -> 
  maybe (field "RawDataLength" int_decoder) >>= fun ln_raw_data_length -> 
  maybe (field "RawData" string) >>= fun ln_raw_data ->
  maybe (field "ResetSeqNumFlag" bool) >>= fun ln_reset_seq_num_flag -> 
  maybe (field "NextExpectedMsgSeqNum" int) >>= fun ln_next_expected_msg_seq_num -> 
  maybe (field "MaxMessageSize" int) >>= fun ln_max_message_size -> 
  maybe (field "TestMessageIndicator" bool) >>= fun ln_test_message_indicator -> 
  maybe (field "Username" string) >>= fun ln_username -> 
  maybe (field "Password" string) >>= fun ln_password ->
  list (field "MsgTypes" full_msg_types_inner_rg_decoder) >>= fun ln_msg_types -> 
  D.succeed {
    ln_encrypt_method
  ; ln_heartbeat_interval
  ; ln_raw_data_length
  ; ln_raw_data
  ; ln_reset_seq_num_flag 
  ; ln_next_expected_msg_seq_num = Option.map Z.of_int ln_next_expected_msg_seq_num
  ; ln_max_message_size = Option.map Z.of_int ln_max_message_size
  ; ln_test_message_indicator
  ; ln_username 
  ; ln_password
  ; ln_msg_types  
  }

let full_msg_logoff_decoder : full_msg_logoff_data D.decoder = 
  let open D in 
  (maybe (field "EncodedTextLen" int)) >>= fun lo_encoded_text_len -> 
  (maybe (field "EncodedText" string)) >>= fun lo_encoded_text -> 
  D.succeed {
    lo_encoded_text_len = Option.map Z.of_int lo_encoded_text_len
  ; lo_encoded_text
  }

;;

(*

(** *)
let full_msg_resend_request_to_json x = 
    [ ( "BeginSeqNo", int_to_json x.rr_begin_seq_num ) 
    ; ( "EndSeqNo"  , int_to_json x.rr_end_seq_num   ) 
    ] |> assoc_filter_nulls 
;;

(** *)
let full_msg_reject_to_json x = 
    [ ( "RefSeqNum"           , int_to_json                         x.sr_ref_seq_num           ) 
    ; ( "RefTagID"            , full_field_tag_opt_to_json          x.sr_ref_tag_id            ) 
    ; ( "RefMsgType"          , full_msg_tag_opt_to_json            x.sr_ref_msg_type          ) 
    ; ( "SessionRejectReason" , session_reject_reason_opt_to_json   x.sr_session_reject_reason )
    ; ( "Text"                , string_opt_to_json                  x.sr_text                  ) 
    ; ( "EncodedTextLen"      , int_opt_to_json                     x.sr_encoded_text_len      ) 
    ; ( "EncodedText"         , string_opt_to_json                  x.sr_encoded_text          ) 
    ] |> assoc_filter_nulls 
;;

(** *)
let full_msg_sequence_reset_to_json x = 
    [ ( "Sequence_Reset_GapFillFlag" , int_to_json             x.seqr_new_seq_no     )
    ; ( "Sequence_Reset_NewSeqNo"    , gapFillFlag_opt_to_json x.seqr_gap_fill_flag  )
    ] |> assoc_filter_nulls 
;;

(** *)
let full_msg_test_request_to_json x = 
    [ ( "Test_Request_TestReqID_Tag" , string_to_json x.test_req_id ) 
    ] |> assoc_filter_nulls 
;;

(** *)
let full_msg_business_reject_to_json x = 
    [ ( "RefSeqNum"             , int_to_json                     x.br_ref_seq_num           ) 
    ; ( "RefMsgType"            , full_msg_tag_to_json            x.br_ref_msg_type          ) 
    ; ( "BusinessRejectRefID"   , full_field_tag_opt_to_json      x.br_ref_field_id          ) 
    ; ( "BusinessRejectReason"  , business_reject_reason_to_json  x.br_business_reject_reason) 
    ; ( "Text"                  , string_opt_to_json              x.br_text                  ) 
    ; ( "EncodedTextLen"        , int_opt_to_json                 x.br_encoded_text_len      ) 
    ; ( "EncodedText"           , string_opt_to_json              x.br_encoded_text          ) 
    ] |> assoc_filter_nulls 
;;

(** *)
let full_admin_msg_to_json x : json = match x with
    | Full_Msg_Heartbeat        x -> `Assoc [ ( "Heartbeat"       , full_msg_heartbeat_to_json x       ) ]
    | Full_Msg_Logon            x -> `Assoc [ ( "Logon"           , full_msg_logon_to_json x           ) ]
    | Full_Msg_Logoff           x -> `Assoc [ ( "Logoff"          , full_msg_logoff_to_json x          ) ]
    | Full_Msg_Reject           x -> `Assoc [ ( "Reject"          , full_msg_reject_to_json x          ) ]
    | Full_Msg_Business_Reject  x -> `Assoc [ ( "Business_Reject" , full_msg_business_reject_to_json x ) ]
    | Full_Msg_Resend_Request   x -> `Assoc [ ( "Resend_Request"  , full_msg_resend_request_to_json x  ) ]
    | Full_Msg_Sequence_Reset   x -> `Assoc [ ( "Sequence_Reset"  , full_msg_sequence_reset_to_json x  ) ]
    | Full_Msg_Test_Request     x -> `Assoc [ ( "Test_Request"    , full_msg_test_request_to_json x    ) ]
;;
[@@@logic]
*)
